#!/usr/bin/env python3

import sys
sys.path.append('/home/y-tanabe/proj/compprog-clib/tool')

import argparse, os, re
from subprocess import run
from argparse import Namespace
import util
from util import warn, die, getPage, debug
import time
from shutil import copyfile

ptopdir = '/home/y-tanabe/proj/compprog-clib'
lc_dir = '/home/y-tanabe/proj/library-checker-problems'
generate_cmd = f'{lc_dir}/generate.py'
test_top = f'{ptopdir}/yosupo-test/tests'

def makeMakefile(path: str) -> None:
    with open(path, 'w', encoding='UTF-8') as wfp:
        print('''
### If you want to build with debug options, invoke make as:
###     make DEBUG=yes

CXX := g++

ifneq ($(DEBUG),yes)
  DEBUGFLAGS := -O2
else
  DEBUGFLAGS := -g -O0 -D_GLIBCXX_DEBUG -DDEBUG=1 -fsanitize=address,undefined -fno-sanitize-recover -fno-omit-frame-pointer
  ifneq ($(DEBUG_LIB),)
    DEBUGFLAGS := $(DEBUGFLAGS) -DDEBUG_LIB=1
  endif
endif

# WARNINGS := -Wall -Wno-format-security -Wshadow -Wconversion -fconcepts
WARNINGS := -Wall -Wno-format-security -Wshadow -fconcepts

CXXFLAGS := -std=gnu++23 $(DEBUGFLAGS) $(WARNINGS)

CXXFLAGS := $(CXXFLAGS) -I/home/y-tanabe/lib/boost_1_73_0
CXXFLAGS := $(CXXFLAGS) -I/home/y-tanabe/proj/compprog-clib/ac-library
CXXFLAGS := $(CXXFLAGS) $(if $(CMPNAIVE),-DCMPNAIVE=1)
CXXFLAGS := $(CXXFLAGS)

skels := $(wildcard *_skel.cc)
ts := $(patsubst %_skel.cc,%_t.cc,$(skels))
pars := $(patsubst %_skel.cc,/home/y-tanabe/proj/compprog-clib/%.cc,$(skels))
makefiles := $(patsubst %_skel.cc,%_t.d,$(skels))
execsSub := $(patsubst %_skel.cc,%_t,$(skels))
execs := $(execsSub) convolutionS_t

all: c_t

include $(makefiles)

%_t.cc %_t.d &: %_skel.cc
	/home/y-tanabe/proj/compprog-clib/tool/libins --clib-dir /home/y-tanabe/proj/compprog-clib -M -o $*_t.cc -i $*_skel.cc --orig-lineno

%: %.cc
	$(CXX) -o $@ $(CXXFLAGS) $<

convolutionS_t: convolution_t.cc
	$(CXX) -o convolutionS_t $(CXXFLAGS) -DTEST_CONSTANT_MOD=1 convolution_t.cc


# If you need intermediate %_.cc files, uncomment the following line.
# .PRECIOUS:  %_t.cc

clean:
	$(RM) $(ts) $(execs) $(makefiles) *~ \#*

check:
	echo $(execs)
''', file=wfp)

def makeSource(path: str) -> None:
    with open(path, 'w', encoding='UTF-8') as wfp:
        print('''#include <bits/stdc++.h>
#include <cassert>
using namespace std;
using ll = long long int;
using u64 = unsigned long long;
using pll = pair<ll, ll>;
// #include <atcoder/all>
// using namespace atcoder;
#define REP(i, a, b) for (ll i = (a); i < (b); i++)
#define REPrev(i, a, b) for (ll i = (a); i >= (b); i--)
#define ALL(coll) (coll).begin(), (coll).end()
#define SIZE(v) ((ll)((v).size()))
#define REPOUT(i, a, b, exp, sep) REP(i, (a), (b)) cout << (exp) << (i + 1 == (b) ? "" : (sep)); cout << "\\n"

// @@ !! LIM()

int main(/* int argc, char *argv[] */) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  return 0;
}
''', file=wfp)

def main():
    args = parseArgs()
    for p in args.pid:
        cp = run([generate_cmd, '-p', p])
        if cp.returncode != 0:
            die(f'{generate_cmd} failed.')
        destdir = f'{test_top}/{p}'
        os.makedirs(destdir, exist_ok=True)
        ppath = f'{lc_dir}/{p}'
        for file_in in os.listdir(f'{ppath}/in'):
            if file_in.endswith('.in'):
                base = file_in[:-3]
                file_out_path = f'{ppath}/out/{base}.out'
                if not os.path.exists(file_out_path):
                    warn(f'Cannot find {file_out_path}.  Skipped.')
                else:
                    file_in_path = f'{ppath}/in/{file_in}'
                    copyfile(file_in_path, f'{destdir}/din_{base}.txt')
                    copyfile(file_out_path, f'{destdir}/dexp_{base}.txt')
        src_path = f'{destdir}/c_skel.cc'
        if os.path.exists(src_path):
            warn(f'Warning: {src_path} exists.  It was not overwritten.')
        else:
            makeSource(src_path)
        makefile_path = f'{destdir}/Makefile'
        if os.path.exists(makefile_path):
            warn(f'Warning: {makefile_path} exists.  It was not overwritten.')
        else:
            makeMakefile(makefile_path)
        

def parseArgs() -> Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='''
'''
    )
    parser.add_argument(
        'pid', type=str, nargs='*',
        help='problem id such as graph/shortest_path')
    return parser.parse_args()

main()
